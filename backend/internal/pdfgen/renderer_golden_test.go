package pdfgen

import (
	"bytes"
	"encoding/json"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"testing"

	"resume_maker/backend/internal/models"
)

type pdfFixture struct {
	Request models.GeneratePDFRequest `json:"request"`
	Expect  pdfExpectation            `json:"expect"`
}

type pdfExpectation struct {
	HasURI         bool `json:"hasURI"`
	HasImage       bool `json:"hasImage"`
	MinPageMarkers int  `json:"minPageMarkers"`
}

func TestPDFGoldenFixtures(t *testing.T) {
	t.Helper()

	generator := Generator{}
	updateGolden := strings.TrimSpace(os.Getenv("UPDATE_PDF_GOLDEN")) == "1"

	fixturePaths, err := filepath.Glob(filepath.Join("testdata", "fixtures", "*.json"))
	if err != nil {
		t.Fatalf("glob fixture files: %v", err)
	}
	if len(fixturePaths) == 0 {
		t.Fatal("no PDF fixtures found in testdata/fixtures")
	}
	sort.Strings(fixturePaths)

	for _, fixturePath := range fixturePaths {
		fixturePath := fixturePath
		name := strings.TrimSuffix(filepath.Base(fixturePath), filepath.Ext(fixturePath))

		t.Run(name, func(t *testing.T) {
			raw, readErr := os.ReadFile(fixturePath)
			if readErr != nil {
				t.Fatalf("read fixture %s: %v", fixturePath, readErr)
			}

			var fixture pdfFixture
			if unmarshalErr := json.Unmarshal(raw, &fixture); unmarshalErr != nil {
				t.Fatalf("unmarshal fixture %s: %v", fixturePath, unmarshalErr)
			}

			pdfBytes, genErr := generator.Generate(fixture.Request)
			if genErr != nil {
				t.Fatalf("generate PDF for fixture %s: %v", fixturePath, genErr)
			}

			assertPDFExpectations(t, pdfBytes, fixture.Expect)

			goldenPath := filepath.Join("testdata", "golden", name+".pdf")
			if updateGolden {
				if writeErr := os.WriteFile(goldenPath, pdfBytes, 0o644); writeErr != nil {
					t.Fatalf("write golden file %s: %v", goldenPath, writeErr)
				}
			}

			goldenBytes, goldenErr := os.ReadFile(goldenPath)
			if goldenErr != nil {
				t.Fatalf("read golden file %s: %v", goldenPath, goldenErr)
			}

			actualSignature := buildGoldenSignature(pdfBytes)
			expectedSignature := buildGoldenSignature(goldenBytes)
			if actualSignature != expectedSignature {
				t.Fatalf(
					"PDF golden signature mismatch for %s\nactual=%+v\nexpected=%+v\nTo refresh fixtures run: UPDATE_PDF_GOLDEN=1 go test ./internal/pdfgen -run TestPDFGoldenFixtures -count=1",
					name,
					actualSignature,
					expectedSignature,
				)
			}
		})
	}
}

func assertPDFExpectations(t *testing.T, pdfBytes []byte, expect pdfExpectation) {
	t.Helper()

	if !bytes.HasPrefix(pdfBytes, []byte("%PDF")) {
		t.Fatal("generated bytes do not start with %PDF")
	}

	pageMarkers := bytes.Count(pdfBytes, []byte("/Type /Page"))
	if pageMarkers < expect.MinPageMarkers {
		t.Fatalf("expected at least %d page markers, got %d", expect.MinPageMarkers, pageMarkers)
	}

	hasURI := bytes.Contains(pdfBytes, []byte("/URI"))
	if expect.HasURI && !hasURI {
		t.Fatal("expected PDF to include clickable URI annotations")
	}
	if !expect.HasURI && hasURI {
		t.Fatal("expected PDF to have no URI annotations")
	}

	hasImage := bytes.Contains(pdfBytes, []byte("/Subtype /Image"))
	if expect.HasImage && !hasImage {
		t.Fatal("expected PDF to include embedded image objects")
	}
	if !expect.HasImage && hasImage {
		t.Fatal("expected PDF to have no embedded image objects")
	}
}

var baseFontPattern = regexp.MustCompile(`/BaseFont /([A-Za-z0-9_+]+)`)
var subsetFontPrefixPattern = regexp.MustCompile(`^[A-Z]{6}\+`)

type goldenSignature struct {
	PDFPrefix      string
	PageMarkers    int
	URICount       int
	ImageCount     int
	BaseFontJoined string
}

func buildGoldenSignature(payload []byte) goldenSignature {
	prefix := ""
	if len(payload) >= 8 {
		prefix = string(payload[:8])
	}

	baseFontMatches := baseFontPattern.FindAllSubmatch(payload, -1)
	normalizedFonts := make([]string, 0, len(baseFontMatches))
	for _, match := range baseFontMatches {
		if len(match) < 2 {
			continue
		}
		fontName := subsetFontPrefixPattern.ReplaceAllString(string(match[1]), "")
		normalizedFonts = append(normalizedFonts, fontName)
	}
	sort.Strings(normalizedFonts)

	return goldenSignature{
		PDFPrefix:      prefix,
		PageMarkers:    bytes.Count(payload, []byte("/Type /Page")),
		URICount:       bytes.Count(payload, []byte("/URI")),
		ImageCount:     bytes.Count(payload, []byte("/Subtype /Image")),
		BaseFontJoined: strings.Join(normalizedFonts, "|"),
	}
}
